// daily chart.
// If you want manual S/R add prices in the Manual SR fields.
// Turn signalOnly = true to only use alerts. For backtesting, set signalOnly = false.
// Set alerts on the alert conditions "BuySignal" / "SellSignal".

// @version=5
strategy("5/10 EMA + Stoch + Daily S/R (EOD signals)", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=1, calc_on_every_tick=false)

// === Inputs
emaFastLen = input.int(5, "Fast EMA (5)")
emaSlowLen = input.int(10, "Slow EMA (10)")
stochKlen = input.int(14, "Stochastic %K length")
stochDlen = input.int(3, "Stochastic %D length")
stochSmooth = input.int(3, "Stochastic smooth")
stochOB = input.int(80, "Stoch Overbought")
stochOS = input.int(20, "Stoch Oversold")
pivotLen = input.int(5, "Pivot length for auto S/R", minval=2)
rangePct = input.float(0.5, "Near S/R tolerance (%)", step=0.1)

// Manual S/R (optional). Enter comma separated prices or leave empty.
s1 = input.string("", "Manual SR1 (price or blank)")
s2 = input.string("", "Manual SR2 (price or blank)")
s3 = input.string("", "Manual SR3 (price or blank)")
s4 = input.string("", "Manual SR4 (price or blank)")

autoSR = input.bool(true, "Use automatic pivot S/R (recommended)")
allowCounterTrend = input.bool(false, "Allow counter-trend trades? (if true, ignores EMA alignment)")

signalOnly = input.bool(true, "Signal only (no auto-execution)")
takeProfitR = input.float(2.0, "TP in R (risk multiples)", step=0.1)
useFixedSL = input.bool(false, "Use fixed SL in pips/ticks instead of structure-based SL")
fixedSL = input.float(200, "Fixed SL (ticks/pips) if enabled")

// === Calculations
emaFast = ta.ema(close, emaFastLen)
emaSlow = ta.ema(close, emaSlowLen)
plot(emaFast, color=color.yellow, title="EMA 5")
plot(emaSlow, color=color.orange, title="EMA 10")

// Stoch
k = ta.stoch(close, high, low, stochKlen)
k_s = ta.sma(k, stochSmooth)
d = ta.sma(k_s, stochDlen)
plot(k_s, title="%K (smooth)", linewidth=1)
hline(stochOB, "OB", color=color.red)
hline(stochOS, "OS", color=color.green)

// Automatic pivot S/R: collect pivot highs/lows as SR levels
var float[] srLevels = array.new_float()
if barstate.islastconfirmedhistory
    // compute pivots on history only (cheap)
    for i = pivotLen to 1 by -1
        ph = ta.pivothigh(high, pivotLen, pivotLen)
        pl = ta.pivotlow(low, pivotLen, pivotLen)
    // clear and recompute
    array.clear(srLevels)
    phv = ta.pivothigh(high, pivotLen, pivotLen)
    plv = ta.pivotlow(low, pivotLen, pivotLen)
    // collect recent pivots across lookback
    lookback = pivotLen * 15
    for i = 0 to lookback
        phx = ta.pivothigh(high, pivotLen, pivotLen)[i]
        plx = ta.pivotlow(low, pivotLen, pivotLen)[i]
        if not na(phx)
            array.push(srLevels, phx)
        if not na(plx)
            array.push(srLevels, plx)

// Manual SR parsing helper
f_toFloat(s) =>
    f = na
    if str.length(s) > 0
        f := str.tonumber(s)
    else
        f := na
    f

manLevels = array.new_float()
for s in [s1,s2,s3,s4]
    v = f_toFloat(s)
    if not na(v)
        array.push(manLevels, v)

// create final SR list (manual overrides first)
finalSR = array.new_float()
for i = 0 to array.size(manLevels)-1
    array.push(finalSR, array.get(manLevels, i))
if autoSR
    for i = 0 to array.size(srLevels)-1
        array.push(finalSR, array.get(srLevels, i))

// plot SR levels (limit to 8)
maxPlot = math.min(array.size(finalSR), 8)
for i = 0 to maxPlot-1
    lvl = array.get(finalSR, i)
    line.new(x1=bar_index-500, y1=lvl, x2=bar_index+5, y2=lvl, color=color.new(color.blue, 85), width=1)

// === Helper: near SR?
nearSR(price) =>
    for i=0 to array.size(finalSR)-1
        lvl = array.get(finalSR, i)
        tol = price * (rangePct / 100.0)
        if math.abs(price - lvl) <= tol
            true
    false

// EMA trend
bullTrend = emaFast > emaSlow
bearTrend = emaFast < emaSlow

// Stoch cross logic at close
stochCrossUp = ta.crossover(k_s, d)
stochCrossDown = ta.crossunder(k_s, d)

// Price near SR?
isNearSR = nearSR(close)

// Setup conditions
buyCond = (allowCounterTrend or bullTrend) and stochCrossUp and isNearSR
sellCond = (allowCounterTrend or bearTrend) and stochCrossDown and isNearSR

// Risk/SL: we set SL below nearest SR for buys, above for sells.
nearestSR(price, isBuy) =>
    var float best = na
    var float minDist = 1e12
    for i = 0 to array.size(finalSR)-1
        lvl = array.get(finalSR, i)
        dist = math.abs(price - lvl)
        if dist < minDist
            minDist := dist
            best := lvl
    // ensure SL on correct side for buy/sell
    if not na(best)
        if isBuy and best >= price
            // if nearest is above price (resistance), find other
            for j = 0 to array.size(finalSR)-1
                l2 = array.get(finalSR,j)
                if l2 < price
                    best := l2
        if not isBuy and best <= price
            for j = 0 to array.size(finalSR)-1
                l2 = array.get(finalSR,j)
                if l2 > price
                    best := l2
    best

// determine SL and TP price levels and R distance
var float slPrice = na
var float tpPrice = na
if buyCond
    slL = nearestSR(close, true)
    if not na(slL)
        slPrice := slL - 0.000 // small buffer can be added by user
        rr = close - slPrice
        tpPrice := close + (takeProfitR * rr)
    else
        slPrice := na
if sellCond
    slL = nearestSR(close, false)
    if not na(slL)
        slPrice := slL + 0.000
        rr = slPrice - close
        tpPrice := close - (takeProfitR * rr)
    else
        slPrice := na

// Plot signals
plotshape(buyCond and barstate.isconfirmed, style=shape.triangleup, location=location.belowbar, color=color.green, size=size.small, title="BuySignal")
plotshape(sellCond and barstate.isconfirmed, style=shape.triangledown, location=location.abovebar, color=color.red, size=size.small, title="SellSignal")

// Strategy trading (optional)
if not signalOnly and buyCond and barstate.isconfirmed
    // compute qty from strategy.percent_of_equity configured in strategy() header or default
    // use strategy.entry with stop and limit for TP/SL
    if not na(slPrice) and not na(tpPrice)
        strategy.entry("Long", strategy.long)
        strategy.exit("ExitLong", "Long", stop=slPrice, limit=tpPrice)
    else
        strategy.entry("Long", strategy.long)

if not signalOnly and sellCond and barstate.isconfirmed
    if not na(slPrice) and not na(tpPrice)
        strategy.entry("Short", strategy.short)
        strategy.exit("ExitShort", "Short", stop=slPrice, limit=tpPrice)
    else
        strategy.entry("Short", strategy.short)

// Alerts
alertcondition(buyCond and barstate.isconfirmed, title="BuySignal", message="5/10EMA + Stoch BUY near SR at close on {{ticker}}")
alertcondition(sellCond and barstate.isconfirmed, title="SellSignal", message="5/10EMA + Stoch SELL near SR at close on {{ticker}}")

// Info box
var label info = na
if barstate.islast
    lbl = "EMA: " + (bullTrend ? "Bull" : bearTrend ? "Bear" : "Flat") + " | NearSR: " + tostring(isNearSR) + " | StochK: " + tostring(k_s)
    if na(info)
        info := label.new(bar_index, high, lbl, xloc = xloc.bar_index, yloc = yloc.abovebar, style=label.style_label_left, textcolor=color.white, size=size.tiny)
    else
        label.set_xy(info, bar_index, high)
        label.set_text(info, lbl)
